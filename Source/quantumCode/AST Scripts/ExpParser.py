# Generated from Exp.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,54,511,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,1,0,1,0,1,0,5,0,88,8,0,10,0,12,0,91,9,0,1,0,
        1,0,1,0,3,0,96,8,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,121,8,1,1,2,1,
        2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
        3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
        3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
        3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
        3,1,3,1,3,1,3,3,3,192,8,3,1,4,1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,
        5,1,5,1,6,1,6,1,6,1,6,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,
        9,1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,1,
        11,1,12,1,12,1,12,1,12,1,13,1,13,1,13,1,13,1,14,1,14,1,14,1,14,1,
        15,1,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,17,1,17,1,17,1,
        17,1,17,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,
        18,1,18,1,18,3,18,275,8,18,1,19,1,19,1,19,1,19,1,19,1,19,1,19,4,
        19,284,8,19,11,19,12,19,285,1,19,1,19,1,19,1,20,1,20,1,20,1,20,1,
        20,1,20,1,20,4,20,298,8,20,11,20,12,20,299,1,20,1,20,1,20,1,21,1,
        21,1,21,1,21,1,21,1,21,1,21,4,21,312,8,21,11,21,12,21,313,1,21,1,
        21,1,21,1,22,1,22,1,22,1,22,1,22,1,22,1,22,4,22,326,8,22,11,22,12,
        22,327,1,22,1,22,1,22,1,23,1,23,1,23,1,24,1,24,1,24,1,24,1,24,1,
        24,1,24,1,24,1,24,1,24,1,24,4,24,347,8,24,11,24,12,24,348,1,24,1,
        24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,
        26,1,26,1,26,1,26,3,26,369,8,26,1,27,1,27,1,27,1,27,1,27,1,27,1,
        27,1,27,5,27,379,8,27,10,27,12,27,382,9,27,1,27,1,27,1,27,1,27,1,
        27,1,28,1,28,1,28,1,28,1,28,5,28,394,8,28,10,28,12,28,397,9,28,1,
        28,1,28,1,28,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,30,1,30,1,
        30,1,30,1,30,1,30,1,30,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,32,1,
        32,1,32,1,32,1,32,1,32,1,32,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,
        33,1,33,1,33,1,33,4,33,442,8,33,11,33,12,33,443,1,33,1,33,1,33,1,
        33,1,33,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,
        34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,472,8,34,1,
        35,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,38,1,38,1,38,1,38,1,
        38,1,38,1,38,1,39,1,39,1,39,1,39,1,40,1,40,1,40,1,41,1,41,1,41,1,
        41,5,41,501,8,41,10,41,12,41,504,9,41,1,41,1,41,1,41,1,41,1,41,1,
        41,0,0,42,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,
        40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,
        0,0,516,0,89,1,0,0,0,2,120,1,0,0,0,4,122,1,0,0,0,6,191,1,0,0,0,8,
        193,1,0,0,0,10,197,1,0,0,0,12,204,1,0,0,0,14,208,1,0,0,0,16,213,
        1,0,0,0,18,218,1,0,0,0,20,223,1,0,0,0,22,228,1,0,0,0,24,233,1,0,
        0,0,26,237,1,0,0,0,28,241,1,0,0,0,30,245,1,0,0,0,32,250,1,0,0,0,
        34,255,1,0,0,0,36,274,1,0,0,0,38,276,1,0,0,0,40,290,1,0,0,0,42,304,
        1,0,0,0,44,318,1,0,0,0,46,332,1,0,0,0,48,335,1,0,0,0,50,355,1,0,
        0,0,52,368,1,0,0,0,54,370,1,0,0,0,56,388,1,0,0,0,58,401,1,0,0,0,
        60,409,1,0,0,0,62,416,1,0,0,0,64,423,1,0,0,0,66,430,1,0,0,0,68,471,
        1,0,0,0,70,473,1,0,0,0,72,476,1,0,0,0,74,479,1,0,0,0,76,482,1,0,
        0,0,78,489,1,0,0,0,80,493,1,0,0,0,82,496,1,0,0,0,84,85,3,50,25,0,
        85,86,6,0,-1,0,86,88,1,0,0,0,87,84,1,0,0,0,88,91,1,0,0,0,89,87,1,
        0,0,0,89,90,1,0,0,0,90,95,1,0,0,0,91,89,1,0,0,0,92,93,3,6,3,0,93,
        94,6,0,-1,0,94,96,1,0,0,0,95,92,1,0,0,0,95,96,1,0,0,0,96,97,1,0,
        0,0,97,98,6,0,-1,0,98,1,1,0,0,0,99,100,3,46,23,0,100,101,6,1,-1,
        0,101,121,1,0,0,0,102,103,3,36,18,0,103,104,6,1,-1,0,104,121,1,0,
        0,0,105,106,3,52,26,0,106,107,6,1,-1,0,107,121,1,0,0,0,108,109,3,
        38,19,0,109,110,6,1,-1,0,110,121,1,0,0,0,111,112,3,40,20,0,112,113,
        6,1,-1,0,113,121,1,0,0,0,114,115,3,42,21,0,115,116,6,1,-1,0,116,
        121,1,0,0,0,117,118,3,44,22,0,118,119,6,1,-1,0,119,121,1,0,0,0,120,
        99,1,0,0,0,120,102,1,0,0,0,120,105,1,0,0,0,120,108,1,0,0,0,120,111,
        1,0,0,0,120,114,1,0,0,0,120,117,1,0,0,0,121,3,1,0,0,0,122,123,3,
        10,5,0,123,124,6,2,-1,0,124,5,1,0,0,0,125,126,3,2,1,0,126,127,6,
        3,-1,0,127,192,1,0,0,0,128,129,3,48,24,0,129,130,6,3,-1,0,130,192,
        1,0,0,0,131,132,3,54,27,0,132,133,6,3,-1,0,133,192,1,0,0,0,134,135,
        3,56,28,0,135,136,6,3,-1,0,136,192,1,0,0,0,137,138,3,58,29,0,138,
        139,6,3,-1,0,139,192,1,0,0,0,140,141,3,60,30,0,141,142,6,3,-1,0,
        142,192,1,0,0,0,143,144,3,62,31,0,144,145,6,3,-1,0,145,192,1,0,0,
        0,146,147,3,64,32,0,147,148,6,3,-1,0,148,192,1,0,0,0,149,150,3,66,
        33,0,150,151,6,3,-1,0,151,192,1,0,0,0,152,153,3,8,4,0,153,154,6,
        3,-1,0,154,192,1,0,0,0,155,156,3,12,6,0,156,157,6,3,-1,0,157,192,
        1,0,0,0,158,159,3,14,7,0,159,160,6,3,-1,0,160,192,1,0,0,0,161,162,
        3,16,8,0,162,163,6,3,-1,0,163,192,1,0,0,0,164,165,3,18,9,0,165,166,
        6,3,-1,0,166,192,1,0,0,0,167,168,3,20,10,0,168,169,6,3,-1,0,169,
        192,1,0,0,0,170,171,3,22,11,0,171,172,6,3,-1,0,172,192,1,0,0,0,173,
        174,3,24,12,0,174,175,6,3,-1,0,175,192,1,0,0,0,176,177,3,26,13,0,
        177,178,6,3,-1,0,178,192,1,0,0,0,179,180,3,28,14,0,180,181,6,3,-1,
        0,181,192,1,0,0,0,182,183,3,30,15,0,183,184,6,3,-1,0,184,192,1,0,
        0,0,185,186,3,32,16,0,186,187,6,3,-1,0,187,192,1,0,0,0,188,189,3,
        34,17,0,189,190,6,3,-1,0,190,192,1,0,0,0,191,125,1,0,0,0,191,128,
        1,0,0,0,191,131,1,0,0,0,191,134,1,0,0,0,191,137,1,0,0,0,191,140,
        1,0,0,0,191,143,1,0,0,0,191,146,1,0,0,0,191,149,1,0,0,0,191,152,
        1,0,0,0,191,155,1,0,0,0,191,158,1,0,0,0,191,161,1,0,0,0,191,164,
        1,0,0,0,191,167,1,0,0,0,191,170,1,0,0,0,191,173,1,0,0,0,191,176,
        1,0,0,0,191,179,1,0,0,0,191,182,1,0,0,0,191,185,1,0,0,0,191,188,
        1,0,0,0,192,7,1,0,0,0,193,194,5,30,0,0,194,195,3,10,5,0,195,196,
        6,4,-1,0,196,9,1,0,0,0,197,198,5,1,0,0,198,199,3,2,1,0,199,200,5,
        2,0,0,200,201,3,2,1,0,201,202,5,3,0,0,202,203,6,5,-1,0,203,11,1,
        0,0,0,204,205,5,31,0,0,205,206,3,10,5,0,206,207,6,6,-1,0,207,13,
        1,0,0,0,208,209,5,32,0,0,209,210,3,10,5,0,210,211,3,6,3,0,211,212,
        6,7,-1,0,212,15,1,0,0,0,213,214,5,33,0,0,214,215,3,2,1,0,215,216,
        3,6,3,0,216,217,6,8,-1,0,217,17,1,0,0,0,218,219,5,34,0,0,219,220,
        3,2,1,0,220,221,3,6,3,0,221,222,6,9,-1,0,222,19,1,0,0,0,223,224,
        5,35,0,0,224,225,3,2,1,0,225,226,3,6,3,0,226,227,6,10,-1,0,227,21,
        1,0,0,0,228,229,5,36,0,0,229,230,3,2,1,0,230,231,3,6,3,0,231,232,
        6,11,-1,0,232,23,1,0,0,0,233,234,5,37,0,0,234,235,3,2,1,0,235,236,
        6,12,-1,0,236,25,1,0,0,0,237,238,5,38,0,0,238,239,3,2,1,0,239,240,
        6,13,-1,0,240,27,1,0,0,0,241,242,5,39,0,0,242,243,3,2,1,0,243,244,
        6,14,-1,0,244,29,1,0,0,0,245,246,5,40,0,0,246,247,3,2,1,0,247,248,
        3,2,1,0,248,249,6,15,-1,0,249,31,1,0,0,0,250,251,5,41,0,0,251,252,
        3,2,1,0,252,253,3,2,1,0,253,254,6,16,-1,0,254,33,1,0,0,0,255,256,
        5,42,0,0,256,257,3,6,3,0,257,258,3,6,3,0,258,259,6,17,-1,0,259,35,
        1,0,0,0,260,261,5,45,0,0,261,275,6,18,-1,0,262,263,5,4,0,0,263,264,
        5,45,0,0,264,275,6,18,-1,0,265,266,5,45,0,0,266,267,5,44,0,0,267,
        268,5,45,0,0,268,275,6,18,-1,0,269,270,5,4,0,0,270,271,5,45,0,0,
        271,272,5,44,0,0,272,273,5,45,0,0,273,275,6,18,-1,0,274,260,1,0,
        0,0,274,262,1,0,0,0,274,265,1,0,0,0,274,269,1,0,0,0,275,37,1,0,0,
        0,276,277,5,1,0,0,277,278,5,5,0,0,278,279,3,6,3,0,279,283,6,19,-1,
        0,280,281,3,6,3,0,281,282,6,19,-1,0,282,284,1,0,0,0,283,280,1,0,
        0,0,284,285,1,0,0,0,285,283,1,0,0,0,285,286,1,0,0,0,286,287,1,0,
        0,0,287,288,5,3,0,0,288,289,6,19,-1,0,289,39,1,0,0,0,290,291,5,1,
        0,0,291,292,5,4,0,0,292,293,3,6,3,0,293,297,6,20,-1,0,294,295,3,
        6,3,0,295,296,6,20,-1,0,296,298,1,0,0,0,297,294,1,0,0,0,298,299,
        1,0,0,0,299,297,1,0,0,0,299,300,1,0,0,0,300,301,1,0,0,0,301,302,
        5,3,0,0,302,303,6,20,-1,0,303,41,1,0,0,0,304,305,5,1,0,0,305,306,
        5,6,0,0,306,307,3,6,3,0,307,311,6,21,-1,0,308,309,3,6,3,0,309,310,
        6,21,-1,0,310,312,1,0,0,0,311,308,1,0,0,0,312,313,1,0,0,0,313,311,
        1,0,0,0,313,314,1,0,0,0,314,315,1,0,0,0,315,316,5,3,0,0,316,317,
        6,21,-1,0,317,43,1,0,0,0,318,319,5,1,0,0,319,320,5,7,0,0,320,321,
        3,6,3,0,321,325,6,22,-1,0,322,323,3,6,3,0,323,324,6,22,-1,0,324,
        326,1,0,0,0,325,322,1,0,0,0,326,327,1,0,0,0,327,325,1,0,0,0,327,
        328,1,0,0,0,328,329,1,0,0,0,329,330,5,3,0,0,330,331,6,22,-1,0,331,
        45,1,0,0,0,332,333,5,46,0,0,333,334,6,23,-1,0,334,47,1,0,0,0,335,
        336,5,1,0,0,336,337,5,16,0,0,337,346,5,1,0,0,338,339,5,1,0,0,339,
        340,5,46,0,0,340,341,5,8,0,0,341,342,3,68,34,0,342,343,3,6,3,0,343,
        344,5,3,0,0,344,345,6,24,-1,0,345,347,1,0,0,0,346,338,1,0,0,0,347,
        348,1,0,0,0,348,346,1,0,0,0,348,349,1,0,0,0,349,350,1,0,0,0,350,
        351,5,3,0,0,351,352,3,6,3,0,352,353,5,3,0,0,353,354,6,24,-1,0,354,
        49,1,0,0,0,355,356,5,1,0,0,356,357,5,15,0,0,357,358,5,46,0,0,358,
        359,5,8,0,0,359,360,3,68,34,0,360,361,3,6,3,0,361,362,5,3,0,0,362,
        363,6,25,-1,0,363,51,1,0,0,0,364,365,5,28,0,0,365,369,6,26,-1,0,
        366,367,5,29,0,0,367,369,6,26,-1,0,368,364,1,0,0,0,368,366,1,0,0,
        0,369,53,1,0,0,0,370,371,5,1,0,0,371,372,5,18,0,0,372,380,5,1,0,
        0,373,374,5,46,0,0,374,375,5,8,0,0,375,376,3,68,34,0,376,377,6,27,
        -1,0,377,379,1,0,0,0,378,373,1,0,0,0,379,382,1,0,0,0,380,378,1,0,
        0,0,380,381,1,0,0,0,381,383,1,0,0,0,382,380,1,0,0,0,383,384,5,3,
        0,0,384,385,3,6,3,0,385,386,5,3,0,0,386,387,6,27,-1,0,387,55,1,0,
        0,0,388,389,5,1,0,0,389,395,3,6,3,0,390,391,3,6,3,0,391,392,6,28,
        -1,0,392,394,1,0,0,0,393,390,1,0,0,0,394,397,1,0,0,0,395,393,1,0,
        0,0,395,396,1,0,0,0,396,398,1,0,0,0,397,395,1,0,0,0,398,399,5,3,
        0,0,399,400,6,28,-1,0,400,57,1,0,0,0,401,402,5,1,0,0,402,403,5,19,
        0,0,403,404,3,6,3,0,404,405,3,6,3,0,405,406,3,6,3,0,406,407,5,3,
        0,0,407,408,6,29,-1,0,408,59,1,0,0,0,409,410,5,1,0,0,410,411,5,25,
        0,0,411,412,3,6,3,0,412,413,3,6,3,0,413,414,5,3,0,0,414,415,6,30,
        -1,0,415,61,1,0,0,0,416,417,5,1,0,0,417,418,5,26,0,0,418,419,3,6,
        3,0,419,420,3,6,3,0,420,421,5,3,0,0,421,422,6,31,-1,0,422,63,1,0,
        0,0,423,424,5,1,0,0,424,425,5,27,0,0,425,426,3,6,3,0,426,427,3,6,
        3,0,427,428,5,3,0,0,428,429,6,32,-1,0,429,65,1,0,0,0,430,431,5,1,
        0,0,431,432,5,17,0,0,432,441,5,1,0,0,433,434,5,1,0,0,434,435,5,46,
        0,0,435,436,5,8,0,0,436,437,3,68,34,0,437,438,3,6,3,0,438,439,5,
        3,0,0,439,440,6,33,-1,0,440,442,1,0,0,0,441,433,1,0,0,0,442,443,
        1,0,0,0,443,441,1,0,0,0,443,444,1,0,0,0,444,445,1,0,0,0,445,446,
        5,3,0,0,446,447,3,6,3,0,447,448,5,3,0,0,448,449,6,33,-1,0,449,67,
        1,0,0,0,450,451,3,70,35,0,451,452,6,34,-1,0,452,472,1,0,0,0,453,
        454,3,82,41,0,454,455,6,34,-1,0,455,472,1,0,0,0,456,457,3,74,37,
        0,457,458,6,34,-1,0,458,472,1,0,0,0,459,460,3,76,38,0,460,461,6,
        34,-1,0,461,472,1,0,0,0,462,463,3,80,40,0,463,464,6,34,-1,0,464,
        472,1,0,0,0,465,466,3,78,39,0,466,467,6,34,-1,0,467,472,1,0,0,0,
        468,469,3,72,36,0,469,470,6,34,-1,0,470,472,1,0,0,0,471,450,1,0,
        0,0,471,453,1,0,0,0,471,456,1,0,0,0,471,459,1,0,0,0,471,462,1,0,
        0,0,471,465,1,0,0,0,471,468,1,0,0,0,472,69,1,0,0,0,473,474,5,9,0,
        0,474,475,6,35,-1,0,475,71,1,0,0,0,476,477,5,10,0,0,477,478,6,36,
        -1,0,478,73,1,0,0,0,479,480,5,11,0,0,480,481,6,37,-1,0,481,75,1,
        0,0,0,482,483,5,1,0,0,483,484,3,68,34,0,484,485,5,2,0,0,485,486,
        3,68,34,0,486,487,5,3,0,0,487,488,6,38,-1,0,488,77,1,0,0,0,489,490,
        5,12,0,0,490,491,3,68,34,0,491,492,6,39,-1,0,492,79,1,0,0,0,493,
        494,5,13,0,0,494,495,6,40,-1,0,495,81,1,0,0,0,496,502,5,1,0,0,497,
        498,3,68,34,0,498,499,6,41,-1,0,499,501,1,0,0,0,500,497,1,0,0,0,
        501,504,1,0,0,0,502,500,1,0,0,0,502,503,1,0,0,0,503,505,1,0,0,0,
        504,502,1,0,0,0,505,506,5,14,0,0,506,507,3,68,34,0,507,508,5,3,0,
        0,508,509,6,41,-1,0,509,83,1,0,0,0,16,89,95,120,191,274,285,299,
        313,327,348,368,380,395,443,471,502
    ]

class ExpParser ( Parser ):

    grammarFileName = "Exp.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'('", "','", "')'", "'-'", "'+'", "'*'", 
                     "'/'", "':'", "'bool'", "'unit'", "'num'", "'Ref'", 
                     "'Str'", "'->'", "'define'", "'let'", "'letrec'", "'lambda'", 
                     "'if'", "'car'", "'cdr'", "'cons'", "'list'", "'null?'", 
                     "'<'", "'='", "'>'", "'#t'", "'#f'", "'SKIP'", "'X'", 
                     "'CU'", "'RZ'", "'RRZ'", "'SR'", "'SRR'", "'Lshift'", 
                     "'Rshift'", "'Rev'", "'QFT'", "'RQFT'", "';'", "'self'", 
                     "'.'", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'@'", "'...'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "Define", "Let", 
                      "Letrec", "Lambda", "If", "Car", "Cdr", "Cons", "List", 
                      "Null", "Less", "Equal", "Greater", "TrueLiteral", 
                      "FalseLiteral", "SKIPEXP", "Xgate", "CU", "RZ", "RRZ", 
                      "SR", "SRR", "Lshift", "Rshift", "Rev", "QFT", "RQFT", 
                      "Seq", "Self", "Dot", "Number", "Identifier", "Letter", 
                      "LetterOrDigit", "StrLiteral", "AT", "ELLIPSIS", "WS", 
                      "Comment", "Line_Comment" ]

    RULE_program = 0
    RULE_vexp = 1
    RULE_posi = 2
    RULE_exp = 3
    RULE_skipexp = 4
    RULE_posiexp = 5
    RULE_xgexp = 6
    RULE_cuexp = 7
    RULE_rzexp = 8
    RULE_rrzexp = 9
    RULE_srexp = 10
    RULE_srrexp = 11
    RULE_lshiftexp = 12
    RULE_rshiftexp = 13
    RULE_revexp = 14
    RULE_qftexp = 15
    RULE_rqftexp = 16
    RULE_seqexp = 17
    RULE_numexp = 18
    RULE_addexp = 19
    RULE_subexp = 20
    RULE_multexp = 21
    RULE_divexp = 22
    RULE_varexp = 23
    RULE_letexp = 24
    RULE_definedecl = 25
    RULE_boolexp = 26
    RULE_lambdaexp = 27
    RULE_callexp = 28
    RULE_ifexp = 29
    RULE_lessexp = 30
    RULE_equalexp = 31
    RULE_greaterexp = 32
    RULE_letrecexp = 33
    RULE_typea = 34
    RULE_booleantype = 35
    RULE_unittype = 36
    RULE_numtype = 37
    RULE_pairtype = 38
    RULE_reft = 39
    RULE_stringt = 40
    RULE_funct = 41

    ruleNames =  [ "program", "vexp", "posi", "exp", "skipexp", "posiexp", 
                   "xgexp", "cuexp", "rzexp", "rrzexp", "srexp", "srrexp", 
                   "lshiftexp", "rshiftexp", "revexp", "qftexp", "rqftexp", 
                   "seqexp", "numexp", "addexp", "subexp", "multexp", "divexp", 
                   "varexp", "letexp", "definedecl", "boolexp", "lambdaexp", 
                   "callexp", "ifexp", "lessexp", "equalexp", "greaterexp", 
                   "letrecexp", "typea", "booleantype", "unittype", "numtype", 
                   "pairtype", "reft", "stringt", "funct" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    Define=15
    Let=16
    Letrec=17
    Lambda=18
    If=19
    Car=20
    Cdr=21
    Cons=22
    List=23
    Null=24
    Less=25
    Equal=26
    Greater=27
    TrueLiteral=28
    FalseLiteral=29
    SKIPEXP=30
    Xgate=31
    CU=32
    RZ=33
    RRZ=34
    SR=35
    SRR=36
    Lshift=37
    Rshift=38
    Rev=39
    QFT=40
    RQFT=41
    Seq=42
    Self=43
    Dot=44
    Number=45
    Identifier=46
    Letter=47
    LetterOrDigit=48
    StrLiteral=49
    AT=50
    ELLIPSIS=51
    WS=52
    Comment=53
    Line_Comment=54

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.defs = None
            self.expr = None
            self.defa = None # DefinedeclContext
            self.e = None # ExpContext

        def definedecl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.DefinedeclContext)
            else:
                return self.getTypedRuleContext(ExpParser.DefinedeclContext,i)


        def exp(self):
            return self.getTypedRuleContext(ExpParser.ExpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = ExpParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
         localctx.defs =  new ArrayList<DefineDecl>() localctx.expr =  new UnitExp() 
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 89
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 84
                    localctx.defa = self.definedecl()
                     localctx.defs.add(localctx.defa.ast);  
                self.state = 91
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

            self.state = 95
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 114348940853266) != 0):
                self.state = 92
                localctx.e = self.exp()
                 localctx.expr =  localctx.e.ast 


             localctx.ast =  new Program(localctx.defs, localctx.expr) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.va = None # VarexpContext
            self.num = None # NumexpContext
            self.bl = None # BoolexpContext
            self.add = None # AddexpContext
            self.sub = None # SubexpContext
            self.mul = None # MultexpContext
            self.div = None # DivexpContext

        def varexp(self):
            return self.getTypedRuleContext(ExpParser.VarexpContext,0)


        def numexp(self):
            return self.getTypedRuleContext(ExpParser.NumexpContext,0)


        def boolexp(self):
            return self.getTypedRuleContext(ExpParser.BoolexpContext,0)


        def addexp(self):
            return self.getTypedRuleContext(ExpParser.AddexpContext,0)


        def subexp(self):
            return self.getTypedRuleContext(ExpParser.SubexpContext,0)


        def multexp(self):
            return self.getTypedRuleContext(ExpParser.MultexpContext,0)


        def divexp(self):
            return self.getTypedRuleContext(ExpParser.DivexpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_vexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVexp" ):
                listener.enterVexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVexp" ):
                listener.exitVexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVexp" ):
                return visitor.visitVexp(self)
            else:
                return visitor.visitChildren(self)




    def vexp(self):

        localctx = ExpParser.VexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_vexp)
        try:
            self.state = 120
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 99
                localctx.va = self.varexp()
                 localctx.ast =  localctx.va.ast 
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 102
                localctx.num = self.numexp()
                 localctx.ast =  localctx.num.ast 
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 105
                localctx.bl = self.boolexp()
                 localctx.ast =  localctx.bl.ast 
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 108
                localctx.add = self.addexp()
                 localctx.ast =  localctx.add.ast 
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 111
                localctx.sub = self.subexp()
                 localctx.ast =  localctx.sub.ast 
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 114
                localctx.mul = self.multexp()
                 localctx.ast =  localctx.mul.ast 
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 117
                localctx.div = self.divexp()
                 localctx.ast =  localctx.div.ast 
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PosiContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.posii = None # PosiexpContext

        def posiexp(self):
            return self.getTypedRuleContext(ExpParser.PosiexpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_posi

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosi" ):
                listener.enterPosi(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosi" ):
                listener.exitPosi(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPosi" ):
                return visitor.visitPosi(self)
            else:
                return visitor.visitChildren(self)




    def posi(self):

        localctx = ExpParser.PosiContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_posi)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            localctx.posii = self.posiexp()
            localctx.ast =  localctx.posii.ast
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.vxx = None # VexpContext
            self.let = None # LetexpContext
            self.lam = None # LambdaexpContext
            self.call = None # CallexpContext
            self.i = None # IfexpContext
            self.less = None # LessexpContext
            self.eq = None # EqualexpContext
            self.gt = None # GreaterexpContext
            self.lrec = None # LetrecexpContext
            self.skipa = None # SkipexpContext
            self.xgate = None # XgexpContext
            self.cu = None # CuexpContext
            self.rz = None # RzexpContext
            self.rrz = None # RrzexpContext
            self.sr = None # SrexpContext
            self.srr = None # SrrexpContext
            self.lshift = None # LshiftexpContext
            self.rshift = None # RshiftexpContext
            self.rev = None # RevexpContext
            self.qft = None # QftexpContext
            self.rqft = None # RqftexpContext
            self.seq = None # SeqexpContext

        def vexp(self):
            return self.getTypedRuleContext(ExpParser.VexpContext,0)


        def letexp(self):
            return self.getTypedRuleContext(ExpParser.LetexpContext,0)


        def lambdaexp(self):
            return self.getTypedRuleContext(ExpParser.LambdaexpContext,0)


        def callexp(self):
            return self.getTypedRuleContext(ExpParser.CallexpContext,0)


        def ifexp(self):
            return self.getTypedRuleContext(ExpParser.IfexpContext,0)


        def lessexp(self):
            return self.getTypedRuleContext(ExpParser.LessexpContext,0)


        def equalexp(self):
            return self.getTypedRuleContext(ExpParser.EqualexpContext,0)


        def greaterexp(self):
            return self.getTypedRuleContext(ExpParser.GreaterexpContext,0)


        def letrecexp(self):
            return self.getTypedRuleContext(ExpParser.LetrecexpContext,0)


        def skipexp(self):
            return self.getTypedRuleContext(ExpParser.SkipexpContext,0)


        def xgexp(self):
            return self.getTypedRuleContext(ExpParser.XgexpContext,0)


        def cuexp(self):
            return self.getTypedRuleContext(ExpParser.CuexpContext,0)


        def rzexp(self):
            return self.getTypedRuleContext(ExpParser.RzexpContext,0)


        def rrzexp(self):
            return self.getTypedRuleContext(ExpParser.RrzexpContext,0)


        def srexp(self):
            return self.getTypedRuleContext(ExpParser.SrexpContext,0)


        def srrexp(self):
            return self.getTypedRuleContext(ExpParser.SrrexpContext,0)


        def lshiftexp(self):
            return self.getTypedRuleContext(ExpParser.LshiftexpContext,0)


        def rshiftexp(self):
            return self.getTypedRuleContext(ExpParser.RshiftexpContext,0)


        def revexp(self):
            return self.getTypedRuleContext(ExpParser.RevexpContext,0)


        def qftexp(self):
            return self.getTypedRuleContext(ExpParser.QftexpContext,0)


        def rqftexp(self):
            return self.getTypedRuleContext(ExpParser.RqftexpContext,0)


        def seqexp(self):
            return self.getTypedRuleContext(ExpParser.SeqexpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_exp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExp" ):
                listener.enterExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExp" ):
                listener.exitExp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExp" ):
                return visitor.visitExp(self)
            else:
                return visitor.visitChildren(self)




    def exp(self):

        localctx = ExpParser.ExpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_exp)
        try:
            self.state = 191
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 125
                localctx.vxx = self.vexp()
                 localctx.ast =  localctx.vxx.ast 
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 128
                localctx.let = self.letexp()
                 localctx.ast =  localctx.let.ast 
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 131
                localctx.lam = self.lambdaexp()
                 localctx.ast =  localctx.lam.ast 
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 134
                localctx.call = self.callexp()
                 localctx.ast =  localctx.call.ast 
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 137
                localctx.i = self.ifexp()
                 localctx.ast =  localctx.i.ast 
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 140
                localctx.less = self.lessexp()
                 localctx.ast =  localctx.less.ast 
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 143
                localctx.eq = self.equalexp()
                 localctx.ast =  localctx.eq.ast 
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 146
                localctx.gt = self.greaterexp()
                 localctx.ast =  localctx.gt.ast 
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 149
                localctx.lrec = self.letrecexp()
                 localctx.ast =  localctx.lrec.ast 
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 152
                localctx.skipa = self.skipexp()
                localctx.ast =  localctx.skipa.ast
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 155
                localctx.xgate = self.xgexp()
                localctx.ast =  localctx.xgate.ast
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 158
                localctx.cu = self.cuexp()
                localctx.ast =  cu.ast
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 161
                localctx.rz = self.rzexp()
                localctx.ast =  rz.ast
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 164
                localctx.rrz = self.rrzexp()
                localctx.ast =  rrz.ast
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 167
                localctx.sr = self.srexp()
                localctx.ast =  sr.ast
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 170
                localctx.srr = self.srrexp()
                localctx.ast =  srr.ast
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 173
                localctx.lshift = self.lshiftexp()
                localctx.ast =  lshift.ast
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 176
                localctx.rshift = self.rshiftexp()
                localctx.ast =  rshift.ast
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 179
                localctx.rev = self.revexp()
                localctx.ast =  rev.ast
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 182
                localctx.qft = self.qftexp()
                localctx.ast =  qft.ast
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 185
                localctx.rqft = self.rqftexp()
                localctx.ast =  rqft.ast
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 188
                localctx.seq = self.seqexp()
                localctx.ast =  seq.ast
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SkipexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # PosiexpContext

        def SKIPEXP(self):
            return self.getToken(ExpParser.SKIPEXP, 0)

        def posiexp(self):
            return self.getTypedRuleContext(ExpParser.PosiexpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_skipexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkipexp" ):
                listener.enterSkipexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkipexp" ):
                listener.exitSkipexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkipexp" ):
                return visitor.visitSkipexp(self)
            else:
                return visitor.visitChildren(self)




    def skipexp(self):

        localctx = ExpParser.SkipexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_skipexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(ExpParser.SKIPEXP)
            self.state = 194
            localctx.e1 = self.posiexp()
             localctx.ast =  new SkipExp(e1) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PosiexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # VexpContext
            self.e2 = None # VexpContext

        def vexp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.VexpContext)
            else:
                return self.getTypedRuleContext(ExpParser.VexpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_posiexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosiexp" ):
                listener.enterPosiexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosiexp" ):
                listener.exitPosiexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPosiexp" ):
                return visitor.visitPosiexp(self)
            else:
                return visitor.visitChildren(self)




    def posiexp(self):

        localctx = ExpParser.PosiexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_posiexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(ExpParser.T__0)
            self.state = 198
            localctx.e1 = self.vexp()
            self.state = 199
            self.match(ExpParser.T__1)
            self.state = 200
            localctx.e2 = self.vexp()
            self.state = 201
            self.match(ExpParser.T__2)
             localctx.ast =  new PosiExp(localctx.e1.ast,localctx.e2.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XgexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e = None # PosiexpContext

        def Xgate(self):
            return self.getToken(ExpParser.Xgate, 0)

        def posiexp(self):
            return self.getTypedRuleContext(ExpParser.PosiexpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_xgexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXgexp" ):
                listener.enterXgexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXgexp" ):
                listener.exitXgexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXgexp" ):
                return visitor.visitXgexp(self)
            else:
                return visitor.visitChildren(self)




    def xgexp(self):

        localctx = ExpParser.XgexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_xgexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 204
            self.match(ExpParser.Xgate)
            self.state = 205
            localctx.e = self.posiexp()
            localctx.ast = new XExp(localctx.e.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CuexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # PosiexpContext
            self.e2 = None # ExpContext

        def CU(self):
            return self.getToken(ExpParser.CU, 0)

        def posiexp(self):
            return self.getTypedRuleContext(ExpParser.PosiexpContext,0)


        def exp(self):
            return self.getTypedRuleContext(ExpParser.ExpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_cuexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCuexp" ):
                listener.enterCuexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCuexp" ):
                listener.exitCuexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCuexp" ):
                return visitor.visitCuexp(self)
            else:
                return visitor.visitChildren(self)




    def cuexp(self):

        localctx = ExpParser.CuexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_cuexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.match(ExpParser.CU)
            self.state = 209
            localctx.e1 = self.posiexp()
            self.state = 210
            localctx.e2 = self.exp()
            localctx.ast = new CUExp(localctx.e1.ast, localctx.e2.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RzexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # VexpContext
            self.e2 = None # ExpContext

        def RZ(self):
            return self.getToken(ExpParser.RZ, 0)

        def vexp(self):
            return self.getTypedRuleContext(ExpParser.VexpContext,0)


        def exp(self):
            return self.getTypedRuleContext(ExpParser.ExpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_rzexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRzexp" ):
                listener.enterRzexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRzexp" ):
                listener.exitRzexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRzexp" ):
                return visitor.visitRzexp(self)
            else:
                return visitor.visitChildren(self)




    def rzexp(self):

        localctx = ExpParser.RzexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_rzexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(ExpParser.RZ)
            self.state = 214
            localctx.e1 = self.vexp()
            self.state = 215
            localctx.e2 = self.exp()
            localctx.ast = new RZExp(localctx.e1.ast, localctx.e2.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RrzexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # VexpContext
            self.e2 = None # ExpContext

        def RRZ(self):
            return self.getToken(ExpParser.RRZ, 0)

        def vexp(self):
            return self.getTypedRuleContext(ExpParser.VexpContext,0)


        def exp(self):
            return self.getTypedRuleContext(ExpParser.ExpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_rrzexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRrzexp" ):
                listener.enterRrzexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRrzexp" ):
                listener.exitRrzexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRrzexp" ):
                return visitor.visitRrzexp(self)
            else:
                return visitor.visitChildren(self)




    def rrzexp(self):

        localctx = ExpParser.RrzexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_rrzexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            self.match(ExpParser.RRZ)
            self.state = 219
            localctx.e1 = self.vexp()
            self.state = 220
            localctx.e2 = self.exp()
            localctx.ast = new RRZExp(localctx.e1.ast, localctx.e2.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SrexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # VexpContext
            self.e2 = None # ExpContext

        def SR(self):
            return self.getToken(ExpParser.SR, 0)

        def vexp(self):
            return self.getTypedRuleContext(ExpParser.VexpContext,0)


        def exp(self):
            return self.getTypedRuleContext(ExpParser.ExpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_srexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSrexp" ):
                listener.enterSrexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSrexp" ):
                listener.exitSrexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSrexp" ):
                return visitor.visitSrexp(self)
            else:
                return visitor.visitChildren(self)




    def srexp(self):

        localctx = ExpParser.SrexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_srexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 223
            self.match(ExpParser.SR)
            self.state = 224
            localctx.e1 = self.vexp()
            self.state = 225
            localctx.e2 = self.exp()
            localctx.ast = new SRExp(localctx.e1.ast, localctx.e2.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SrrexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # VexpContext
            self.e2 = None # ExpContext

        def SRR(self):
            return self.getToken(ExpParser.SRR, 0)

        def vexp(self):
            return self.getTypedRuleContext(ExpParser.VexpContext,0)


        def exp(self):
            return self.getTypedRuleContext(ExpParser.ExpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_srrexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSrrexp" ):
                listener.enterSrrexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSrrexp" ):
                listener.exitSrrexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSrrexp" ):
                return visitor.visitSrrexp(self)
            else:
                return visitor.visitChildren(self)




    def srrexp(self):

        localctx = ExpParser.SrrexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_srrexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 228
            self.match(ExpParser.SRR)
            self.state = 229
            localctx.e1 = self.vexp()
            self.state = 230
            localctx.e2 = self.exp()
            localctx.ast = new SRRExp(localctx.e1.ast, localctx.e2.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LshiftexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # VexpContext

        def Lshift(self):
            return self.getToken(ExpParser.Lshift, 0)

        def vexp(self):
            return self.getTypedRuleContext(ExpParser.VexpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_lshiftexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLshiftexp" ):
                listener.enterLshiftexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLshiftexp" ):
                listener.exitLshiftexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLshiftexp" ):
                return visitor.visitLshiftexp(self)
            else:
                return visitor.visitChildren(self)




    def lshiftexp(self):

        localctx = ExpParser.LshiftexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_lshiftexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.match(ExpParser.Lshift)
            self.state = 234
            localctx.e1 = self.vexp()
            localctx.ast = new LshExp(localctx.e1.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RshiftexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # VexpContext

        def Rshift(self):
            return self.getToken(ExpParser.Rshift, 0)

        def vexp(self):
            return self.getTypedRuleContext(ExpParser.VexpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_rshiftexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRshiftexp" ):
                listener.enterRshiftexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRshiftexp" ):
                listener.exitRshiftexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRshiftexp" ):
                return visitor.visitRshiftexp(self)
            else:
                return visitor.visitChildren(self)




    def rshiftexp(self):

        localctx = ExpParser.RshiftexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_rshiftexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 237
            self.match(ExpParser.Rshift)
            self.state = 238
            localctx.e1 = self.vexp()
            localctx.ast = new RshExp(localctx.e1.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RevexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # VexpContext

        def Rev(self):
            return self.getToken(ExpParser.Rev, 0)

        def vexp(self):
            return self.getTypedRuleContext(ExpParser.VexpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_revexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRevexp" ):
                listener.enterRevexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRevexp" ):
                listener.exitRevexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRevexp" ):
                return visitor.visitRevexp(self)
            else:
                return visitor.visitChildren(self)




    def revexp(self):

        localctx = ExpParser.RevexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_revexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            self.match(ExpParser.Rev)
            self.state = 242
            localctx.e1 = self.vexp()
            localctx.ast = new RevExp(localctx.e1.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QftexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # VexpContext
            self.e2 = None # VexpContext

        def QFT(self):
            return self.getToken(ExpParser.QFT, 0)

        def vexp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.VexpContext)
            else:
                return self.getTypedRuleContext(ExpParser.VexpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_qftexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQftexp" ):
                listener.enterQftexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQftexp" ):
                listener.exitQftexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQftexp" ):
                return visitor.visitQftexp(self)
            else:
                return visitor.visitChildren(self)




    def qftexp(self):

        localctx = ExpParser.QftexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_qftexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            self.match(ExpParser.QFT)
            self.state = 246
            localctx.e1 = self.vexp()
            self.state = 247
            localctx.e2 = self.vexp()
            localctx.ast = new QFTExp(localctx.e1.ast, localctx.e2.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RqftexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # VexpContext
            self.e2 = None # VexpContext

        def RQFT(self):
            return self.getToken(ExpParser.RQFT, 0)

        def vexp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.VexpContext)
            else:
                return self.getTypedRuleContext(ExpParser.VexpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_rqftexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRqftexp" ):
                listener.enterRqftexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRqftexp" ):
                listener.exitRqftexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRqftexp" ):
                return visitor.visitRqftexp(self)
            else:
                return visitor.visitChildren(self)




    def rqftexp(self):

        localctx = ExpParser.RqftexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_rqftexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 250
            self.match(ExpParser.RQFT)
            self.state = 251
            localctx.e1 = self.vexp()
            self.state = 252
            localctx.e2 = self.vexp()
            localctx.ast = new RQFTExp(localctx.e1.ast, localctx.e2.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SeqexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # ExpContext
            self.e2 = None # ExpContext

        def Seq(self):
            return self.getToken(ExpParser.Seq, 0)

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_seqexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSeqexp" ):
                listener.enterSeqexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSeqexp" ):
                listener.exitSeqexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSeqexp" ):
                return visitor.visitSeqexp(self)
            else:
                return visitor.visitChildren(self)




    def seqexp(self):

        localctx = ExpParser.SeqexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_seqexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 255
            self.match(ExpParser.Seq)
            self.state = 256
            localctx.e1 = self.exp()
            self.state = 257
            localctx.e2 = self.exp()
            localctx.ast = new SeqExp(localctx.e1.ast, localctx.e2.ast)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.n0 = None # Token
            self.n1 = None # Token

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(ExpParser.Number)
            else:
                return self.getToken(ExpParser.Number, i)

        def Dot(self):
            return self.getToken(ExpParser.Dot, 0)

        def getRuleIndex(self):
            return ExpParser.RULE_numexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumexp" ):
                listener.enterNumexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumexp" ):
                listener.exitNumexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumexp" ):
                return visitor.visitNumexp(self)
            else:
                return visitor.visitChildren(self)




    def numexp(self):

        localctx = ExpParser.NumexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_numexp)
        try:
            self.state = 274
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 260
                localctx.n0 = self.match(ExpParser.Number)
                 localctx.ast =  new NumExp(Integer.parseInt((None if localctx.n0 is None else localctx.n0.text))) 
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 262
                self.match(ExpParser.T__3)
                self.state = 263
                localctx.n0 = self.match(ExpParser.Number)
                 localctx.ast =  new NumExp(-Integer.parseInt((None if localctx.n0 is None else localctx.n0.text))) 
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 265
                localctx.n0 = self.match(ExpParser.Number)
                self.state = 266
                self.match(ExpParser.Dot)
                self.state = 267
                localctx.n1 = self.match(ExpParser.Number)
                 localctx.ast =  new NumExp(Double.parseDouble((None if localctx.n0 is None else localctx.n0.text)+"."+(None if localctx.n1 is None else localctx.n1.text))) 
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 269
                self.match(ExpParser.T__3)
                self.state = 270
                localctx.n0 = self.match(ExpParser.Number)
                self.state = 271
                self.match(ExpParser.Dot)
                self.state = 272
                localctx.n1 = self.match(ExpParser.Number)
                 localctx.ast =  new NumExp(Double.parseDouble("-" + (None if localctx.n0 is None else localctx.n0.text)+"."+(None if localctx.n1 is None else localctx.n1.text))) 
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.list_ = None
            self.e = None # ExpContext

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_addexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddexp" ):
                listener.enterAddexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddexp" ):
                listener.exitAddexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddexp" ):
                return visitor.visitAddexp(self)
            else:
                return visitor.visitChildren(self)




    def addexp(self):

        localctx = ExpParser.AddexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_addexp)
         localctx.list_ =  new ArrayList<Exp>() 
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 276
            self.match(ExpParser.T__0)
            self.state = 277
            self.match(ExpParser.T__4)
            self.state = 278
            localctx.e = self.exp()
             localctx.list_.add(localctx.e.ast); 
            self.state = 283 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 280
                localctx.e = self.exp()
                 localctx.list_.add(localctx.e.ast); 
                self.state = 285 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 114348940853266) != 0)):
                    break

            self.state = 287
            self.match(ExpParser.T__2)
             localctx.ast =  new AddExp(localctx.list_) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.list_ = None
            self.e = None # ExpContext

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_subexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubexp" ):
                listener.enterSubexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubexp" ):
                listener.exitSubexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubexp" ):
                return visitor.visitSubexp(self)
            else:
                return visitor.visitChildren(self)




    def subexp(self):

        localctx = ExpParser.SubexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_subexp)
         localctx.list_ =  new ArrayList<Exp>() 
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self.match(ExpParser.T__0)
            self.state = 291
            self.match(ExpParser.T__3)
            self.state = 292
            localctx.e = self.exp()
             localctx.list_.add(localctx.e.ast); 
            self.state = 297 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 294
                localctx.e = self.exp()
                 localctx.list_.add(localctx.e.ast); 
                self.state = 299 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 114348940853266) != 0)):
                    break

            self.state = 301
            self.match(ExpParser.T__2)
             localctx.ast =  new SubExp(localctx.list_) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.list_ = None
            self.e = None # ExpContext

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_multexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultexp" ):
                listener.enterMultexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultexp" ):
                listener.exitMultexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultexp" ):
                return visitor.visitMultexp(self)
            else:
                return visitor.visitChildren(self)




    def multexp(self):

        localctx = ExpParser.MultexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_multexp)
         localctx.list_ =  new ArrayList<Exp>() 
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.match(ExpParser.T__0)
            self.state = 305
            self.match(ExpParser.T__5)
            self.state = 306
            localctx.e = self.exp()
             localctx.list_.add(localctx.e.ast); 
            self.state = 311 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 308
                localctx.e = self.exp()
                 localctx.list_.add(localctx.e.ast); 
                self.state = 313 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 114348940853266) != 0)):
                    break

            self.state = 315
            self.match(ExpParser.T__2)
             localctx.ast =  new MultExp(localctx.list_) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DivexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.list_ = None
            self.e = None # ExpContext

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_divexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDivexp" ):
                listener.enterDivexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDivexp" ):
                listener.exitDivexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDivexp" ):
                return visitor.visitDivexp(self)
            else:
                return visitor.visitChildren(self)




    def divexp(self):

        localctx = ExpParser.DivexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_divexp)
         localctx.list_ =  new ArrayList<Exp>() 
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 318
            self.match(ExpParser.T__0)
            self.state = 319
            self.match(ExpParser.T__6)
            self.state = 320
            localctx.e = self.exp()
             localctx.list_.add(localctx.e.ast); 
            self.state = 325 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 322
                localctx.e = self.exp()
                 localctx.list_.add(localctx.e.ast); 
                self.state = 327 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 114348940853266) != 0)):
                    break

            self.state = 329
            self.match(ExpParser.T__2)
             localctx.ast =  new DivExp(localctx.list_) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.ida = None # Token

        def Identifier(self):
            return self.getToken(ExpParser.Identifier, 0)

        def getRuleIndex(self):
            return ExpParser.RULE_varexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarexp" ):
                listener.enterVarexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarexp" ):
                listener.exitVarexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarexp" ):
                return visitor.visitVarexp(self)
            else:
                return visitor.visitChildren(self)




    def varexp(self):

        localctx = ExpParser.VarexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_varexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332
            localctx.ida = self.match(ExpParser.Identifier)
             localctx.ast =  new VarExp((None if localctx.ida is None else localctx.ida.text)) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LetexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.names = None
            self.types = None
            self.value_exps = None
            self.ida = None # Token
            self.t = None # TypeaContext
            self.e = None # ExpContext
            self.body = None # ExpContext

        def Let(self):
            return self.getToken(ExpParser.Let, 0)

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(ExpParser.Identifier)
            else:
                return self.getToken(ExpParser.Identifier, i)

        def typea(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.TypeaContext)
            else:
                return self.getTypedRuleContext(ExpParser.TypeaContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_letexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLetexp" ):
                listener.enterLetexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLetexp" ):
                listener.exitLetexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetexp" ):
                return visitor.visitLetexp(self)
            else:
                return visitor.visitChildren(self)




    def letexp(self):

        localctx = ExpParser.LetexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_letexp)
         localctx.names =  new ArrayList<String>() localctx.types = new ArrayList<Type>() localctx.value_exps =  new ArrayList<Exp>() 
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 335
            self.match(ExpParser.T__0)
            self.state = 336
            self.match(ExpParser.Let)
            self.state = 337
            self.match(ExpParser.T__0)
            self.state = 346 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 338
                self.match(ExpParser.T__0)
                self.state = 339
                localctx.ida = self.match(ExpParser.Identifier)
                self.state = 340
                self.match(ExpParser.T__7)
                self.state = 341
                localctx.t = self.typea()
                self.state = 342
                localctx.e = self.exp()
                self.state = 343
                self.match(ExpParser.T__2)
                 localctx.names.add((None if localctx.ida is None else localctx.ida.text));localctx.types.add(localctx.t.ast); localctx.value_exps.add(localctx.e.ast); 
                self.state = 348 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==1):
                    break

            self.state = 350
            self.match(ExpParser.T__2)
            self.state = 351
            localctx.body = self.exp()
            self.state = 352
            self.match(ExpParser.T__2)
             localctx.ast =  new LetExp(localctx.names, localctx.types, localctx.value_exps, localctx.body.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinedeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.ida = None # Token
            self.t = None # TypeaContext
            self.e = None # ExpContext

        def Define(self):
            return self.getToken(ExpParser.Define, 0)

        def Identifier(self):
            return self.getToken(ExpParser.Identifier, 0)

        def typea(self):
            return self.getTypedRuleContext(ExpParser.TypeaContext,0)


        def exp(self):
            return self.getTypedRuleContext(ExpParser.ExpContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_definedecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinedecl" ):
                listener.enterDefinedecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinedecl" ):
                listener.exitDefinedecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinedecl" ):
                return visitor.visitDefinedecl(self)
            else:
                return visitor.visitChildren(self)




    def definedecl(self):

        localctx = ExpParser.DefinedeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_definedecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 355
            self.match(ExpParser.T__0)
            self.state = 356
            self.match(ExpParser.Define)
            self.state = 357
            localctx.ida = self.match(ExpParser.Identifier)
            self.state = 358
            self.match(ExpParser.T__7)
            self.state = 359
            localctx.t = self.typea()
            self.state = 360
            localctx.e = self.exp()
            self.state = 361
            self.match(ExpParser.T__2)
             localctx.ast =  new DefineDecl((None if localctx.ida is None else localctx.ida.text), localctx.t.ast, localctx.e.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None

        def TrueLiteral(self):
            return self.getToken(ExpParser.TrueLiteral, 0)

        def FalseLiteral(self):
            return self.getToken(ExpParser.FalseLiteral, 0)

        def getRuleIndex(self):
            return ExpParser.RULE_boolexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolexp" ):
                listener.enterBoolexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolexp" ):
                listener.exitBoolexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolexp" ):
                return visitor.visitBoolexp(self)
            else:
                return visitor.visitChildren(self)




    def boolexp(self):

        localctx = ExpParser.BoolexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_boolexp)
        try:
            self.state = 368
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [28]:
                self.enterOuterAlt(localctx, 1)
                self.state = 364
                self.match(ExpParser.TrueLiteral)
                 localctx.ast =  new BoolExp(true) 
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 2)
                self.state = 366
                self.match(ExpParser.FalseLiteral)
                 localctx.ast =  new BoolExp(false) 
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LambdaexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.formals = None
            self.types = None
            self.ida = None # Token
            self.ty = None # TypeaContext
            self.body = None # ExpContext

        def Lambda(self):
            return self.getToken(ExpParser.Lambda, 0)

        def exp(self):
            return self.getTypedRuleContext(ExpParser.ExpContext,0)


        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(ExpParser.Identifier)
            else:
                return self.getToken(ExpParser.Identifier, i)

        def typea(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.TypeaContext)
            else:
                return self.getTypedRuleContext(ExpParser.TypeaContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_lambdaexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLambdaexp" ):
                listener.enterLambdaexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLambdaexp" ):
                listener.exitLambdaexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLambdaexp" ):
                return visitor.visitLambdaexp(self)
            else:
                return visitor.visitChildren(self)




    def lambdaexp(self):

        localctx = ExpParser.LambdaexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_lambdaexp)
         localctx.formals =  new ArrayList<String>() localctx.types =  new ArrayList<Type>() 
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 370
            self.match(ExpParser.T__0)
            self.state = 371
            self.match(ExpParser.Lambda)
            self.state = 372
            self.match(ExpParser.T__0)
            self.state = 380
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==46:
                self.state = 373
                localctx.ida = self.match(ExpParser.Identifier)
                self.state = 374
                self.match(ExpParser.T__7)
                self.state = 375
                localctx.ty = self.typea()
                 localctx.formals.add((None if localctx.ida is None else localctx.ida.text)); localctx.types.add(localctx.ty.ast); 
                self.state = 382
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 383
            self.match(ExpParser.T__2)
            self.state = 384
            localctx.body = self.exp()
            self.state = 385
            self.match(ExpParser.T__2)
            localctx.ast =  new LambdaExp(localctx.formals, localctx.types, localctx.body.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.arguments = new ArrayList<Exp>();
            self.f = None # ExpContext
            self.e = None # ExpContext

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_callexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCallexp" ):
                listener.enterCallexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCallexp" ):
                listener.exitCallexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallexp" ):
                return visitor.visitCallexp(self)
            else:
                return visitor.visitChildren(self)




    def callexp(self):

        localctx = ExpParser.CallexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_callexp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 388
            self.match(ExpParser.T__0)
            self.state = 389
            localctx.f = self.exp()
            self.state = 395
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 114348940853266) != 0):
                self.state = 390
                localctx.e = self.exp()
                 localctx.arguments.add(localctx.e.ast); 
                self.state = 397
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 398
            self.match(ExpParser.T__2)
             localctx.ast =  new CallExp(localctx.f.ast,localctx.arguments) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # ExpContext
            self.e2 = None # ExpContext
            self.e3 = None # ExpContext

        def If(self):
            return self.getToken(ExpParser.If, 0)

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_ifexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfexp" ):
                listener.enterIfexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfexp" ):
                listener.exitIfexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfexp" ):
                return visitor.visitIfexp(self)
            else:
                return visitor.visitChildren(self)




    def ifexp(self):

        localctx = ExpParser.IfexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_ifexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 401
            self.match(ExpParser.T__0)
            self.state = 402
            self.match(ExpParser.If)
            self.state = 403
            localctx.e1 = self.exp()
            self.state = 404
            localctx.e2 = self.exp()
            self.state = 405
            localctx.e3 = self.exp()
            self.state = 406
            self.match(ExpParser.T__2)
             localctx.ast =  new IfExp(localctx.e1.ast,localctx.e2.ast,localctx.e3.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LessexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # ExpContext
            self.e2 = None # ExpContext

        def Less(self):
            return self.getToken(ExpParser.Less, 0)

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_lessexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLessexp" ):
                listener.enterLessexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLessexp" ):
                listener.exitLessexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLessexp" ):
                return visitor.visitLessexp(self)
            else:
                return visitor.visitChildren(self)




    def lessexp(self):

        localctx = ExpParser.LessexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_lessexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 409
            self.match(ExpParser.T__0)
            self.state = 410
            self.match(ExpParser.Less)
            self.state = 411
            localctx.e1 = self.exp()
            self.state = 412
            localctx.e2 = self.exp()
            self.state = 413
            self.match(ExpParser.T__2)
             localctx.ast =  new LessExp(localctx.e1.ast,localctx.e2.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EqualexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # ExpContext
            self.e2 = None # ExpContext

        def Equal(self):
            return self.getToken(ExpParser.Equal, 0)

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_equalexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEqualexp" ):
                listener.enterEqualexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEqualexp" ):
                listener.exitEqualexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEqualexp" ):
                return visitor.visitEqualexp(self)
            else:
                return visitor.visitChildren(self)




    def equalexp(self):

        localctx = ExpParser.EqualexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_equalexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 416
            self.match(ExpParser.T__0)
            self.state = 417
            self.match(ExpParser.Equal)
            self.state = 418
            localctx.e1 = self.exp()
            self.state = 419
            localctx.e2 = self.exp()
            self.state = 420
            self.match(ExpParser.T__2)
             localctx.ast =  new EqualExp(localctx.e1.ast,localctx.e2.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GreaterexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.e1 = None # ExpContext
            self.e2 = None # ExpContext

        def Greater(self):
            return self.getToken(ExpParser.Greater, 0)

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_greaterexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGreaterexp" ):
                listener.enterGreaterexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGreaterexp" ):
                listener.exitGreaterexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGreaterexp" ):
                return visitor.visitGreaterexp(self)
            else:
                return visitor.visitChildren(self)




    def greaterexp(self):

        localctx = ExpParser.GreaterexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_greaterexp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 423
            self.match(ExpParser.T__0)
            self.state = 424
            self.match(ExpParser.Greater)
            self.state = 425
            localctx.e1 = self.exp()
            self.state = 426
            localctx.e2 = self.exp()
            self.state = 427
            self.match(ExpParser.T__2)
             localctx.ast =  new GreaterExp(localctx.e1.ast,localctx.e2.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LetrecexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.ids = new ArrayList<String>()
            self.types = new ArrayList<Type>()
            self.funs = new ArrayList<Exp>();
            self.ida = None # Token
            self.t = None # TypeaContext
            self.fun = None # ExpContext
            self.body = None # ExpContext

        def Letrec(self):
            return self.getToken(ExpParser.Letrec, 0)

        def exp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.ExpContext)
            else:
                return self.getTypedRuleContext(ExpParser.ExpContext,i)


        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(ExpParser.Identifier)
            else:
                return self.getToken(ExpParser.Identifier, i)

        def typea(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.TypeaContext)
            else:
                return self.getTypedRuleContext(ExpParser.TypeaContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_letrecexp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLetrecexp" ):
                listener.enterLetrecexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLetrecexp" ):
                listener.exitLetrecexp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetrecexp" ):
                return visitor.visitLetrecexp(self)
            else:
                return visitor.visitChildren(self)




    def letrecexp(self):

        localctx = ExpParser.LetrecexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_letrecexp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 430
            self.match(ExpParser.T__0)
            self.state = 431
            self.match(ExpParser.Letrec)
            self.state = 432
            self.match(ExpParser.T__0)
            self.state = 441 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 433
                self.match(ExpParser.T__0)
                self.state = 434
                localctx.ida = self.match(ExpParser.Identifier)
                self.state = 435
                self.match(ExpParser.T__7)
                self.state = 436
                localctx.t = self.typea()
                self.state = 437
                localctx.fun = self.exp()
                self.state = 438
                self.match(ExpParser.T__2)
                 localctx.ids.add((None if localctx.ida is None else localctx.ida.text)); localctx.types.add(localctx.t.ast);localctx.funs.add(localctx.fun.ast); 
                self.state = 443 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==1):
                    break

            self.state = 445
            self.match(ExpParser.T__2)
            self.state = 446
            localctx.body = self.exp()
            self.state = 447
            self.match(ExpParser.T__2)
             localctx.ast =  new LetrecExp(localctx.ids, localctx.types, localctx.funs, localctx.body.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.b = None # BooleantypeContext
            self.f = None # FunctContext
            self.n = None # NumtypeContext
            self.p = None # PairtypeContext
            self.s = None # StringtContext
            self.r = None # ReftContext
            self.u = None # UnittypeContext

        def booleantype(self):
            return self.getTypedRuleContext(ExpParser.BooleantypeContext,0)


        def funct(self):
            return self.getTypedRuleContext(ExpParser.FunctContext,0)


        def numtype(self):
            return self.getTypedRuleContext(ExpParser.NumtypeContext,0)


        def pairtype(self):
            return self.getTypedRuleContext(ExpParser.PairtypeContext,0)


        def stringt(self):
            return self.getTypedRuleContext(ExpParser.StringtContext,0)


        def reft(self):
            return self.getTypedRuleContext(ExpParser.ReftContext,0)


        def unittype(self):
            return self.getTypedRuleContext(ExpParser.UnittypeContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_typea

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypea" ):
                listener.enterTypea(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypea" ):
                listener.exitTypea(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypea" ):
                return visitor.visitTypea(self)
            else:
                return visitor.visitChildren(self)




    def typea(self):

        localctx = ExpParser.TypeaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_typea)
        try:
            self.state = 471
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 450
                localctx.b = self.booleantype()
                 localctx.ast =  localctx.b.ast 
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 453
                localctx.f = self.funct()
                 localctx.ast =  localctx.f.ast 
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 456
                localctx.n = self.numtype()
                 localctx.ast =  localctx.n.ast 
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 459
                localctx.p = self.pairtype()
                 localctx.ast =  localctx.p.ast 
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 462
                localctx.s = self.stringt()
                 localctx.ast =  localctx.s.ast 
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 465
                localctx.r = self.reft()
                 localctx.ast =  localctx.r.ast 
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 468
                localctx.u = self.unittype()
                 localctx.ast =  localctx.u.ast 
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleantypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None


        def getRuleIndex(self):
            return ExpParser.RULE_booleantype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleantype" ):
                listener.enterBooleantype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleantype" ):
                listener.exitBooleantype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleantype" ):
                return visitor.visitBooleantype(self)
            else:
                return visitor.visitChildren(self)




    def booleantype(self):

        localctx = ExpParser.BooleantypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_booleantype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 473
            self.match(ExpParser.T__8)
             localctx.ast =  new BoolT() 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnittypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None


        def getRuleIndex(self):
            return ExpParser.RULE_unittype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnittype" ):
                listener.enterUnittype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnittype" ):
                listener.exitUnittype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnittype" ):
                return visitor.visitUnittype(self)
            else:
                return visitor.visitChildren(self)




    def unittype(self):

        localctx = ExpParser.UnittypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_unittype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 476
            self.match(ExpParser.T__9)
             localctx.ast =  new UnitT() 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumtypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None


        def getRuleIndex(self):
            return ExpParser.RULE_numtype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumtype" ):
                listener.enterNumtype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumtype" ):
                listener.exitNumtype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumtype" ):
                return visitor.visitNumtype(self)
            else:
                return visitor.visitChildren(self)




    def numtype(self):

        localctx = ExpParser.NumtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_numtype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 479
            self.match(ExpParser.T__10)
             localctx.ast =  new NumT() 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PairtypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.fst = None # TypeaContext
            self.snd = None # TypeaContext

        def typea(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.TypeaContext)
            else:
                return self.getTypedRuleContext(ExpParser.TypeaContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_pairtype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPairtype" ):
                listener.enterPairtype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPairtype" ):
                listener.exitPairtype(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPairtype" ):
                return visitor.visitPairtype(self)
            else:
                return visitor.visitChildren(self)




    def pairtype(self):

        localctx = ExpParser.PairtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_pairtype)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 482
            self.match(ExpParser.T__0)
            self.state = 483
            localctx.fst = self.typea()
            self.state = 484
            self.match(ExpParser.T__1)
            self.state = 485
            localctx.snd = self.typea()
            self.state = 486
            self.match(ExpParser.T__2)
             localctx.ast =  new PairT(localctx.fst.ast, localctx.snd.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReftContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.ret = None # TypeaContext

        def typea(self):
            return self.getTypedRuleContext(ExpParser.TypeaContext,0)


        def getRuleIndex(self):
            return ExpParser.RULE_reft

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReft" ):
                listener.enterReft(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReft" ):
                listener.exitReft(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReft" ):
                return visitor.visitReft(self)
            else:
                return visitor.visitChildren(self)




    def reft(self):

        localctx = ExpParser.ReftContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_reft)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 489
            self.match(ExpParser.T__11)
            self.state = 490
            localctx.ret = self.typea()
             localctx.ast =  new RefT(localctx.ret.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None


        def getRuleIndex(self):
            return ExpParser.RULE_stringt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringt" ):
                listener.enterStringt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringt" ):
                listener.exitStringt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringt" ):
                return visitor.visitStringt(self)
            else:
                return visitor.visitChildren(self)




    def stringt(self):

        localctx = ExpParser.StringtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_stringt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 493
            self.match(ExpParser.T__12)
              localctx.ast =  new StringT() 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ast = None
            self.formals = None
            self.e = None # TypeaContext
            self.ret = None # TypeaContext

        def typea(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ExpParser.TypeaContext)
            else:
                return self.getTypedRuleContext(ExpParser.TypeaContext,i)


        def getRuleIndex(self):
            return ExpParser.RULE_funct

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunct" ):
                listener.enterFunct(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunct" ):
                listener.exitFunct(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunct" ):
                return visitor.visitFunct(self)
            else:
                return visitor.visitChildren(self)




    def funct(self):

        localctx = ExpParser.FunctContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_funct)
         localctx.formals =  new ArrayList<Type>() 
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 496
            self.match(ExpParser.T__0)
            self.state = 502
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 15874) != 0):
                self.state = 497
                localctx.e = self.typea()
                 localctx.formals.add(localctx.e.ast);
                self.state = 504
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 505
            self.match(ExpParser.T__13)
            self.state = 506
            localctx.ret = self.typea()
            self.state = 507
            self.match(ExpParser.T__2)
             localctx.ast =  new FuncT(localctx.formals, localctx.ret.ast) 
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





