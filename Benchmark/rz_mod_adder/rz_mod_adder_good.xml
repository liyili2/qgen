<let> <id> adder </id> <id type = 'qubits' > x </id> <id type = 'nat' > n </id> <id type = 'nat' > size </id> <id type = 'bits' > M </id> 
   <match> <id> n </id>
          <pair> <vexp> 0 </vexp> <pexp gate = 'SKIP' > <id> x </id> <vexp> 0 </vexp> </pexp> </pair>
           <pair> <vexp op = '+' > <id> m </id> <vexp> 1 </vexp> </vexp> 
               < app > <id> adder </id> <id> x </id> <id> m </id> <id> size </id> <id> M </id> </app> 
               < if > <vexp op = '$' > <id> M </id> <id> m </id> </vexp>
                      <pexp gate = 'SR' > <vexp op = '-' > <id> size </id> <id> n </id> </vexp> <id> x </id> </pexp>
                      <pexp gate = 'SKIP' > <id> x </id> <id> m </id> </pexp>
               </if> 
           </pair>   
   </match>
</let>

<let> <id> sub </id> <id type = 'qubits' > x </id> <id type = 'nat' > n </id> <id type = 'nat' > size </id> <id type = 'bits' > M </id> 
   <match> <id> n </id>
          <pair> <vexp> 0 </vexp> <pexp gate = 'SKIP' > <id> x </id> <vexp> 0 </vexp> </pexp> </pair>
           <pair> <vexp op = '+' > <id> m </id> <vexp> 1 </vexp> </vexp> 
               < app > <id> sub </id> <id> x </id> <id> m </id> <id> size </id> <id> M </id> </app> 
               < if > <vexp op = '$' > <id> M </id> <id> m </id> </vexp>
                      <pexp gate = 'SR' > <vexp op = '-' > <id> n </id> <id> size </id> </vexp> <id> x </id> </pexp>
                      <pexp gate = 'SKIP' > <id> x </id> <id> m </id> </pexp>
               </if> 
           </pair>   
   </match>
</let>


<let> <id> f </id> <id type = 'qubits' > x </id> <id type = 'nat' > n </id> <id type = 'qubits' > c </id> <id type = 'bits' > A </id> <id type = 'bits' > m </id> 
  <app> <id> adder <id> <id> x </id> <id> n </id> <id> a </id> </app>
    <app> <id> sub <id> <id> x </id> <id> n </id> <id> m </id> </app>
    <pexp gate = 'RQFT' > <id> x </id> </pexp>
        <pexp gate = 'CU' > <id> x </id>  <vexp> 0 </vexp> <pexp gate = 'X' > <id> c </id>  <vexp> 0 </vexp> </pexp></pexp>
    <pexp gate = 'QFT' > <id> x </id> <vexp> 0 </vexp> </pexp>
    <pexp gate = 'CU' > <id> c </id>  <vexp> 0 </vexp> <app> <id> adder </id> <id> x </id> <id> n </id> <id> m </id> </app> </pexp>
      <app> <id> sub <id> <id> x </id> <id> n </id> <id> m </id> </app>
    <pexp gate = 'RQFT' > <id> x </id> </pexp>
    <pexp gate = 'X' > <id> x </id>  <vexp> 0 </vexp> </pexp>
        <pexp gate = 'CU' > <id> x </id>  <vexp> 0 </vexp> <pexp gate = 'X' > <id> c </id>  <vexp> 0 </vexp> </pexp></pexp>
     <pexp gate = 'X' > <id> x </id>  <vexp> 0 </vexp> </pexp>
    <pexp gate = 'QFT' > <id> x </id> <vexp> 0 </vexp> </pexp>
    <app> <id> adder <id> <id> x </id> <id> n </id> <id> m </id> </app>
</let>

<pexp gate = 'QFT' > <id> x </id> <vexp> 0 </vexp> </pexp> 
< app > <id> f </id> <id> x </id> <id> na </id> <id> c </id> <id> a </id> <id> m </id> </app> 
<pexp gate = 'RQFT' > <id> x </id> </pexp>

//x is na qubit array, c is one qubit, a and m are two numbers
//m is between 0 and 2^na, b is between 0 and m, c is initialally bit 0 (coq_nval 0) and its result will remain the same.
//result will produce x --> (x + a) % m 

//Definition rz_compare_half (x:var) (n:nat) (c:posi) (M:nat) := 
//   (rz_sub x n (nat2fb M)) ; RQFT x n; (CNOT (x,0) c).

//Definition rz_compare (x:var) (n:nat) (c:posi) (M:nat) := 
// rz_compare_half x n c M ; (inv_exp ( (rz_sub x n (nat2fb M)) ; RQFT x n)).

//Definition qft_cu (x:var) (c:posi) (n:nat) := 
//  RQFT x n;  (CNOT (x,0) c) ; QFT x n.

//Definition qft_acu (x:var) (c:posi) (n:nat) := 
//  RQFT x n;  (X (x,0); CNOT (x,0) c; X (x,0)) ; QFT x n.

//Definition one_cu_adder (x:var) (n:nat) (c:posi) (M:nat -> bool) := CU c (rz_adder x n M).

//Definition mod_adder_half (x:var) (n:nat) (c:posi) (A:nat -> bool) (M:nat -> bool) :=
//   (rz_adder x n A; (rz_sub x n M)) ; qft_cu x c n;  (one_cu_adder x n c M).

//Definition clean_hbit (x:var) (n:nat) (c:posi) (M:nat -> bool) := 
//   (rz_sub x n M) ; qft_acu x c n; ( inv_exp (rz_sub x n M)).

//Definition mod_adder (x:var) (n:nat) (c:posi) (A:nat -> bool) (M:nat -> bool) :=
//  mod_adder_half x n c A M ; clean_hbit x n c A.
