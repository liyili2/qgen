<let>
    <id> divide_mod </id>
    <id> num </id>
    <id> base </id>
    <id> quotient </id>
    <id> remainder </id>
    <id> index </id>
    <id> modulus </id>
    <match>
        <id> num </id>
        <pair>
            <vexp> 0 </vexp>
            <pexp gate = 'SKIP' >
                <id> quotient </id>
                <vexp> 0 </vexp>
            </pexp>
        </pair>
        <pair>
            <vexp op = '+'>
                <id> intermediate </id>
                <vexp> 1 </vexp>
            </vexp>
            <pexp gate = 'SKIP' >
                <id> quotient </id>
                <vexp> 0 </vexp>
            </pexp>
        </pair>
    </match>
</let>

<let>
    <id> halve_num </id>
    <id> num </id>
    <id> base </id>
    <id> quotient </id>
    <id> modulus </id>
    <match>
        <id> num </id>
        <pair>
            <vexp> 0 </vexp>
            <pexp gate = 'SKIP' >
                <id> quotient </id>
                <vexp> 0 </vexp>
            </pexp>
        </pair>
        <pair>
            <vexp op = '+'>
                <id> intermediate </id>
                <vexp> 1 </vexp>
            </vexp>
            <pexp gate = 'SKIP' >
                <id> quotient </id>
                <vexp> 0 </vexp>
            </pexp>
        </pair>
    </match>
</let>

<let>
    <id> recursive_div </id>
    <id> index </id>
    <id> num </id>
    <id> base </id>
    <id> quotient </id>
    <id> remainder </id>
    <id> modulus </id>
    <match>
        <id> index </id>
        <pair>
            <vexp> 0 </vexp>
            <pexp gate = 'SKIP' >
                <id> quotient </id>
                <vexp> 0 </vexp>
            </pexp>
        </pair>
        <pair>
            <vexp op = '+'>
                <id> intermediate </id>
                <vexp> 1 </vexp>
            </vexp>
            <pexp gate = 'SKIP' >
                <id> quotient </id>
                <vexp> 0 </vexp>
            </pexp>
        </pair>
    </match>
</let>

<let>
    <id> left_shift </id>
    <id> num </id>
    <id> quotient </id>
    <match>
        <id> num </id>
        <pair>
            <vexp> 0 </vexp>
            <pexp gate = 'SKIP' >
                <id> quotient </id>
                <vexp> 0 </vexp>
            </pexp>
        </pair>
        <pair>
            <vexp op = '+'>
                <id> intermediate </id>
                <vexp> 1 </vexp>
            </vexp>
            <pexp gate = 'Lshift' >
                <id> quotient </id>
            </pexp>
            <app>
                <id> left_shift </id>
                <id> intermediate </id>
                <id> quotient </id>
            </app>
        </pair>
    </match>
</let>

<pexp gate = 'QFT' >
    <id> quotient </id>
    <vexp> 0 </vexp>
</pexp>

<app>
    <id> recursive_div </id>
    <vexp op = '+' >
        <id> index </id>
        <vexp> 1 </vexp>
    </vexp>
    <id> quotient </id>
    <id> remainder </id>
    <id> num </id>
    <vexp op = '*' >
        <vexp op = '^' >
            <vexp> 2 </vexp>
            <id> index </id>
        </vexp>
        <id> modulus </id>
    </vexp>
</app>

<pexp gate = 'RQFT' >
    <id> quotient </id>
</pexp>

//x and y are two qubit arrays, n bit length, and m is a value betweeo 1 and 2^n, in the end, the value is that (x, y ) --> (x % m, y / m), 

//Fixpoint f i (n:nat) (b:nat) (x ex:var) (M:nat -> bool) := 
//     match i with 0 =>  (SKIP (x,0))
//           | S j => appx_compare_half3 x n b (ex,j) M ;  rshift_by_swap n x;
//                     QFT x (b-1); (CU (ex,j) ((appx_adder x n (b-1) M)));
//                      (X (ex,j)); 
//                     f j n (b-1) x ex (cut_n (div_two_spec M) n)
//     end.
     
     
//Definition appx_div_mod (n:nat) (x ex:var) (M:nat) := 
//    let i := findnum M (n-1) in 
//         (Rev x); QFT x n;
//            appx_moder' (S i) n n x ex (nat2fb (2^i * M)); RQFT x (n - S i); nLshift x (S i);
//         Rev x.
