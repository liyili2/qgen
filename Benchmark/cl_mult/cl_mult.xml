<let> <id> g </id> <id > x </id> <id > re </id> <id > c </id> <id > ca </id> <id > n </id> <id > j </id>
   <match> <id> n </id>
          <pair> <vexp> 0 </vexp> <pexp gate = 'SKIP' > <id> x </id> <vexp> 0 </vexp> </pexp> </pair>
          <pair> <vexp op = '+'> <id> m </id> <vexp>  1 </vexp> </vexp> <pexp gate = 'SKIP' > <id> x </id> <vexp> 0 </vexp> </pexp> </pair>
   </match>
</let>

<let> <id> f </id> <id > n </id> <id > size </id> <id > x </id> <id > y </id> <id > re </id> <id > c </id>
   <match> <id> n </id>
          <pair> <vexp> 0 </vexp> <pexp gate = 'SKIP' > <id> x </id> <vexp> 0 </vexp> </pexp> </pair>
          <pair> <vexp op = '+'> <id> m </id> <vexp>  1 </vexp> </vexp> <pexp gate = 'SKIP' > <id> x </id> <vexp> 0 </vexp> </pexp> </pair>
   </match>
</let>
<app> <id> f </id> <id> n </id> <id> size </id> <id> x </id> <id> y </id> <id> re </id> <id> c </id> </app>


//(x,y,re,c) -> (x,y, re xor (x*y) %2^n,c)
//x and y and re are n-length while c is 1 qubit

//f should call g

//Definition one_cu_cl_full_adder_i (c2:posi) (x:var) (re:var) (c1:posi) (n:nat) (i:nat) := 
 // CU c2 (adder_i n x re c1 i).
//Fixpoint cl_full_mult' (n:nat) (size:nat) (x:var) (y:var) (re:var) (c:posi) :=
//   match n with 
//   | 0 => SKIP (re,0)
//   | S m => cl_full_mult' m size x y re c;
//           one_cu_cl_full_adder_i (y,m) x re c (size-m) m
//   end.

// Here x and y are in nor_mode and re in phi_mode. 
//      [x][y][phi(re)] ->[x][y][phi(x*y mod 2^n)], re is supposed to be zero, 
//    ex is in nor_mode. *)
//Definition cl_full_mult (size:nat) (x y:var) (re:var) (c:posi) :=
//   (cl_full_mult' size size x y re c).

